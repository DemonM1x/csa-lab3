# Архитектура компьютера. Лабораторная работа №3
- Подольский Вячеслав Ильич, P3220
- asm| stack | neum | hw | instr | stuct | stream | port | pstr | prob1 
- Упрощенный вариант


## Содержание

1. [Язык программирования](#язык-программирования)
2. [Организация памяти](#организация-памяти)
3. [Система команд](#система-команд)
4. [Транслятор](#транслятор)
5. [Модель процессора](#модель-процессора)
6. [Тестирование](#тестирование)
7. [Пример использования](#пример-использования)
8. [Пример тестирования исходного кода](#пример-тестирования-исходного-кода)
9. [Статистика](#статистика)


## Язык программирования

### Синтаксис

```ebnf
<program> ::= <section_data>? <section_code>

<section_data> ::= "section data:" <comment>? "\n" <data_line>*
<data_line> ::= <variable> <comment>? "\n"

<variable> ::= <variable_name> ":" <variable_value>
<variable_name> ::= <letter_with_underscore> <letter_or_number_with_underscore>*
<variable_value> ::= <integer>
                   | <string>
                   | <buffer>

<section_code> ::= "section code:" <comment>? "\n" <code_line>*
<code_line> ::= (<label> | <command>) [comment] "\n"

<label> ::= <label_name> ":"
<label_name> ::= <letter_with_underscore> <letter_or_number_with_underscore>*

<command> ::= op0 | op1

<op0> ::= "nop"
        | "drop"
        | "swap"
        | "dup"
        | "over"
        | "inc"
        | "dec"
        | "add"
        | "sub"
        | "mul"
        | "div"
        | "mod"
        | "load"
        | "store"
        | "in"
        | "out"
        | "jmp"
        | "jz"
        | "call"
        | "ret"
        | "hlt"

<op1> ::= "push" <integer>
        | "push" <variable_name>
        | "push" <label_name>

<lowercase_letter> ::= [a-z]
<uppercase_letter> ::= [A-Z]
<letter> ::= <lowercase_letter> | <uppercase_letter>

<integer> ::= [ "-" ] { <any of "0-9"> }

<single_quote> ::= "\'"
<double_quote> ::= "\""
<string> ::= <single_quote> [^\"\n]* <single_quote>
           | <double_quote> [^\'\n]* <double_quote>

<buffer> ::= "bf" positive_integer

<comment> ::= ";" [^\n]*
```

### Семантика

- Код выполняется последовательно, одна инструкция за другой.
Список доступных инструкций см. [система команд](#система-команд)

- В коде данные объявляются в специальном разделе `data`. в которой могут быть 
  объявлены переменные (числа, строки, буферы). Секция данных обязана 
  находиться до секции кода. Типизация переменных статическая.
- Метки определяются на отдельной строке исходного кода:

```asm
label:
        push 1
```
Метки могут быть использованы
до или после определения в исходном коде:
```asm
test:
      push label
      jmp
```
- Метки в коде программы представляют собой
  именованные точки,  на которые можно ссылаться
  из других частей программы. Они не различаются
 по регистру (например, label и LaBeL считаются одной и той же меткой).
 Каждая метка должна быть уникальной,
 и повторное их определение недопустимо.

Метки могут быть использованы множество раз в коде, компилятор
заменит каждое упоминание метки адресом инструкции, следующей за её определением.

- Любая программа обязана иметь метку `start`, указывающую
на первую исполняемую команду.


### Организация памяти:

- Вся внешняя память - статическая
- Память соответствует фон Неймановской архитектуре.
- Машинное слово – не определено. Реализуется высокоуровневой
  структурой данных. 
* Адресация – прямая абсолютная.

```text
            Memory
+------------------------------+
| 00  : push start address (n) |
| 01  : jmp                    |
|    ...                       |
| s+0 : string length          |
| s+1 : string value           |
|    ...                       |
| b+0 : buffer (0)             |
| b+1 : buffer (0)             |
|    ...                       |
| n   : program start          |
| n+1 : instruction            |
|    ...                       |
| 7 : PUSH sub                 |
| 8 : CALL                     |
|    ...                       |
| 25  : subprogram instruction |
| 26  : RET                    |
|    ...                       |
|  n  : HLT                    |
+------------------------------+

```
- Ячейка памяти `0` - отправка адресса первой интрукции программы.
  Ячейка памяти `01` - безусловный переход на первую интрукцию.

Организация стека:

* Стек реализован в виде отдельного регистра, представляющего вершину
  стека (`TOS`) + высокоуровневой структуры данных deque.
* Стек 32-разрядный и позволяет полностью помещать один операнд одной ячейки памяти.

## Система команд

Особенности процессора:

- Машинное слово – не определено.
- Доступ к памяти осуществляется по адресу из специального регистра.
  Значение в нем может быть защелкнуто либо из PC, либо из вершины стека
- Обработка данных осуществляется в стеке. Данные попадают в стек из
  памяти, либо из устройств ввода/вывода.
- Поток управления:
    Значение `PC` инкрементируется после исполнения каждой инструкции,
    Условные (`JZ`) и безусловные (`JMP`) переходы.
Набор инструкций:

  Операции над стеком:
- `push [number]`  - поместить число в top of the stack.
- `drop`  - удалить значение с вершины стека данных.
- `load`  - загрузить из памяти значение по адресу с вершины стека.
- `store`  - положить значение в память по указанному адресу.
- `clear` - очистить стек данных.

  Операции потока программы:
- `NOP` – нет операции.
- `jmp`  - совершить безусловный переход по адрессу из top of the stack
- `jz`  - если элемент равен 0,
  начать исполнять инструкции по указанному адресу.
- `call`  - начать исполнение процедуры по указанному адресу.
- `ret`  - вернуться из процедуры в основную программу, на следующий адрес.

- `hlt` - остановка тактового генератора.

  Арифметические операции:
  - `ADD { e1, e2 }` – положить на стек результат операции сложения e1 + e2.
  - `SUB { e1, e2 }` – положить на стек результат операции вычитания e1 – e2.
  - `MUL { e1, e2 }` – положить на стек результат операции умножения e1 * e2.
  - `DIV { e1, e2 }` – положить на стек результат операции деления e1 / e2.
  - `MOD { e1, e2 }` – положить на стек результат операции взятия остатка e1 % e2.
  - `INC { element }` – увеличить значение top of the stack на 1.
  - `DEC { element }` – уменьшить значение top of the stack на 1. 

- `SWAP { e1, e2 }` – поменять на стеке два элемента местами.
- `OVER { e1 } [ e2 ]` – дублировать первый элемент на стеке через второй.
  Если в стеке только 1 элемент – поведение не определено.
- `in { port }`  - получить данные из внешнего устройства по указанному порту.
- `out { port, value }` - отправить данные во внешнее устройство по указанному порту.

 ## Кодирование инструкций

  Машинный код преобразуется в список JSON,
  где один элемент списка — это одна инструкция.
  Индекс инструкции в списке – адрес этой инструкции в памяти.
  Пример машинного слова:
    
```json
[
    {
        "opcode": "push",
        "arg": 5,
        "term": [
            1,
            5,
            "push 5",
            "]"
        ]
    }
]
```
 - `opcode` -- строка с кодом операции;
 - `arg` -- аргумент (может отсутствовать);
 - `term` -- информация о связанном месте в исходном коде (если есть).

  Типы данных в модуле [isa](./processor/isa.py), где:

- `Opcode` -- перечисление кодов операций;
- `Term` -- структура для описания значимого фрагмента кода исходной программы.


## Транслятор

 Интерфейс командной строки: `translator.py <input_file> <target_file>`

 Реализовано в модуле: [translator](translator.py)

 Этапы трансляции (функция `translate`):

1) Генерация машинного кода без адресов переходов
   и расчёт значений меток перехода.  

2) Подстановка меток перехода в инструкции.

## Модель процессора

Интерфейс командной строки: `machine.py <machine_code_file> <input_file>`

Реализована в модуле [machine](/processor/machine.py).

### DataPath

![DataPath](/resources/DataPath.png)

Реализован в классе `DataPath` в [machine.py](/processor/machine.py)

Управляющие сигналы описаны в модуле [signals](processor/signals.py)

- `DS_PUSH` - защелкнуть вершину стека данных во второй элемент стека данных;
- `DS_POP` - убрать второй элемент из стека данных;
- `LATCH_TOS` - защелкнуть выбранное значение в вершину стека данных:
  - `LATCH_TOS_MEM_OUT` - - защелкнуть значение из памяти
  - `LATCH_TOS_FROM_ALU` - защелкнуть значение из АЛУ
  - `LATCH_TOS_FROM_STACK` - защелкнуть значение второго элемента стека данных
  - `LATCH_TOS_INPUT` - защелкнуть значение из IO контроллера
  - `LATCH_TOS_BR` - защелкнуть значение из буферного регистра
- `LATCH_AR`
  - `LATCH_ADDR_PC` - защелкнуть значение из счетчика команд
  - `LATCH_ADDR_TOS` - защелкнуть значение из вершины стека
- `WRITE` - записать в память по адресу из AR второй элемент стека данных
- `OUT` - отправить второй элемент стека данных на внешнее устройство по порту,
указанному в вершине стека данных

Флаги:
- `zero (z)` - проверка вершины стека на ноль

### ControlUnit

![ControlUnit](/resources/ControlUnit.png)

Реализован в классе `ContolUnit` в [machine.py](processor/machine.py)

- Hardwired (реализовано полностью на Python).
- Метод decode_and_execute_instruction моделирует выполнение полного цикла инструкции (1-2 такта процессора).
- tick_counter необходим для многотактовых инструкций;
  - в реализации класс ControlUnit отсутствует, т.к. неявно задан потоком управления.

    Управляющие Сигналы описаны в модуле [signals](processor/signals.py):
  - `latch_program_counter` - защелкнуть выбранное значение в счетчик команд:
    - `PC_NEXT` - защелкнуть инкрементированное значение счетчика команд
    - `PC_JMP` - защелкнуть значение из вершины стека данных
    - `PC_JZ` - защелкнуть значение из второго элемента стека данных если флаг zero (Z) равен 1, иначе защелкнуть инкрементированное значение из счетчика команд
    - `PC_RS` - защелкнуть значение из вершины стека возврата
  - `RS_PUSH` - защелкнуть в стеке возврата инкрементированное значение счетчика команд
  - `RS_POP` - убрать элемент из стека возврата

    
- Цикл симуляции осуществляется в функции `simulation`.
- Шаг моделирования соответствует одной инструкции с выводом состояния в журнал.
- Для журнала состояний процессора используется стандартный модуль `logging`.
- Количество инструкций для моделирования лимитировано.
- Остановка моделирования осуществляется при:
    - превышении лимита количества выполняемых инструкций;
    - исключении `EOFError` -- если нет данных для чтения из порта ввода;
    - исключении `StopIteration` -- если выполнена инструкция `hlt`.

## Тестирование

Тестирование выполняется при помощи golden test-ов.
Настройки golden тестирования находятся в [golden_test.py](golden_test.py)
Конфигурация golden test-ов лежит в [golden_tests](golden_tests)

Тестовое покрытие:

cat – повторяет поток ввода на вывод
hello_world – печатает на выход “Hello, world!”
hello_username – печатает на выход приветствие пользователя
prob1 – сумма чисел от 1 до 1000, кратные 3 либо 5.

